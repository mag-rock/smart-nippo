# エディタ連携の実装比較

## 概要
GitのコミットメッセージのようにCLIから外部エディタを起動し、入力内容をCLI側で利用する機能の実装方法を各言語で比較します。

## エディタ連携の基本フロー

```
1. CLIがテンポラリファイルを作成
2. 環境変数やデフォルトエディタを検出
3. エディタを起動してテンポラリファイルを開く
4. ユーザーがエディタで編集・保存・終了
5. CLIがテンポラリファイルの内容を読み込み
6. テンポラリファイルを削除
```

## 1. Python

### 標準ライブラリでの実装
```python
import tempfile
import subprocess
import os
from pathlib import Path

def open_editor(initial_content="", file_extension=".md"):
    """外部エディタを開いて入力を受け取る"""
    
    # エディタの検出
    editor = get_editor()
    
    # テンポラリファイルの作成
    with tempfile.NamedTemporaryFile(
        mode='w', 
        suffix=file_extension, 
        delete=False, 
        encoding='utf-8'
    ) as tmp_file:
        if initial_content:
            tmp_file.write(initial_content)
        tmp_file_path = tmp_file.name
    
    try:
        # エディタを起動
        subprocess.run([editor, tmp_file_path], check=True)
        
        # ファイル内容を読み込み
        with open(tmp_file_path, 'r', encoding='utf-8') as f:
            content = f.read().strip()
        
        return content
    
    finally:
        # テンポラリファイルを削除
        Path(tmp_file_path).unlink(missing_ok=True)

def get_editor():
    """エディタを検出"""
    # 1. 環境変数から取得
    for env_var in ['VISUAL', 'EDITOR']:
        editor = os.environ.get(env_var)
        if editor:
            return editor
    
    # 2. プラットフォーム別デフォルト
    import platform
    system = platform.system()
    
    if system == "Windows":
        # Windowsでの検出
        editors = [
            r"C:\Users\{}\AppData\Local\Programs\Microsoft VS Code\Code.exe".format(os.getenv('USERNAME')),
            "code",  # PATH上のVSCode
            "notepad.exe"
        ]
    elif system == "Darwin":  # macOS
        editors = [
            "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code",
            "code",
            "/usr/bin/vim",
            "/usr/bin/nano"
        ]
    else:  # Linux
        editors = [
            "code",
            "vim",
            "nano",
            "gedit"
        ]
    
    # 利用可能なエディタを検索
    for editor in editors:
        if os.path.isfile(editor) or subprocess.run(
            ["which", editor], 
            capture_output=True
        ).returncode == 0:
            return editor
    
    raise RuntimeError("利用可能なエディタが見つかりません")

# 日報入力での使用例
def input_daily_report():
    template = """# 日報 - {date}

## プロジェクト
[プロジェクト名を入力]

## 本日の作業
- 

## 明日の予定
- 

## 所感・課題
"""
    
    from datetime import datetime
    content = open_editor(
        template.format(date=datetime.now().strftime('%Y-%m-%d')),
        file_extension=".md"
    )
    
    return parse_report_content(content)
```

### Clickでの統合
```python
import click

@click.command()
@click.option('--editor', '-e', help='使用するエディタを指定')
def create_report(editor):
    """エディタで日報を作成"""
    if editor:
        os.environ['EDITOR'] = editor
    
    content = open_editor()
    if content:
        save_report(content)
        click.echo("日報を保存しました")
    else:
        click.echo("日報の作成をキャンセルしました")
```

## 2. Go

### 基本実装
```go
package editor

import (
    "fmt"
    "io/ioutil"
    "os"
    "os/exec"
    "path/filepath"
    "runtime"
    "strings"
)

func OpenEditor(initialContent string, fileExt string) (string, error) {
    editor, err := getEditor()
    if err != nil {
        return "", err
    }
    
    // テンポラリファイル作成
    tmpFile, err := ioutil.TempFile("", "smart-nippo-*"+fileExt)
    if err != nil {
        return "", err
    }
    defer os.Remove(tmpFile.Name())
    
    // 初期内容を書き込み
    if initialContent != "" {
        _, err = tmpFile.WriteString(initialContent)
        if err != nil {
            return "", err
        }
    }
    tmpFile.Close()
    
    // エディタを起動
    cmd := exec.Command(editor, tmpFile.Name())
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    
    err = cmd.Run()
    if err != nil {
        return "", err
    }
    
    // ファイル内容を読み込み
    content, err := ioutil.ReadFile(tmpFile.Name())
    if err != nil {
        return "", err
    }
    
    return strings.TrimSpace(string(content)), nil
}

func getEditor() (string, error) {
    // 環境変数から取得
    for _, env := range []string{"VISUAL", "EDITOR"} {
        if editor := os.Getenv(env); editor != "" {
            return editor, nil
        }
    }
    
    // プラットフォーム別デフォルト
    var candidates []string
    switch runtime.GOOS {
    case "windows":
        candidates = []string{
            filepath.Join(os.Getenv("USERPROFILE"), 
                "AppData/Local/Programs/Microsoft VS Code/Code.exe"),
            "code.cmd",
            "notepad.exe",
        }
    case "darwin":
        candidates = []string{
            "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code",
            "code",
            "/usr/bin/vim",
            "/usr/bin/nano",
        }
    default: // Linux
        candidates = []string{
            "code",
            "vim",
            "nano",
            "gedit",
        }
    }
    
    // 利用可能なエディタを検索
    for _, editor := range candidates {
        if _, err := exec.LookPath(editor); err == nil {
            return editor, nil
        }
        if _, err := os.Stat(editor); err == nil {
            return editor, nil
        }
    }
    
    return "", fmt.Errorf("利用可能なエディタが見つかりません")
}

// Cobraでの使用例
func createReportCmd() *cobra.Command {
    return &cobra.Command{
        Use:   "create",
        Short: "エディタで日報を作成",
        Run: func(cmd *cobra.Command, args []string) {
            template := `# 日報 - %s

## プロジェクト
[プロジェクト名を入力]

## 本日の作業
- 

## 明日の予定
- 

## 所感・課題
`
            content, err := OpenEditor(
                fmt.Sprintf(template, time.Now().Format("2006-01-02")),
                ".md",
            )
            if err != nil {
                fmt.Fprintf(os.Stderr, "エラー: %v\n", err)
                return
            }
            
            if content != "" {
                saveReport(content)
                fmt.Println("日報を保存しました")
            } else {
                fmt.Println("日報の作成をキャンセルしました")
            }
        },
    }
}
```

## 3. Node.js

### 基本実装
```javascript
const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawn } = require('child_process');

async function openEditor(initialContent = '', fileExtension = '.md') {
    const editor = getEditor();
    
    // テンポラリファイル作成
    const tmpFile = path.join(
        os.tmpdir(), 
        `smart-nippo-${Date.now()}${fileExtension}`
    );
    
    try {
        // 初期内容を書き込み
        if (initialContent) {
            fs.writeFileSync(tmpFile, initialContent, 'utf8');
        }
        
        // エディタを起動
        await spawnEditor(editor, tmpFile);
        
        // ファイル内容を読み込み
        const content = fs.readFileSync(tmpFile, 'utf8').trim();
        return content;
        
    } finally {
        // テンポラリファイルを削除
        if (fs.existsSync(tmpFile)) {
            fs.unlinkSync(tmpFile);
        }
    }
}

function spawnEditor(editor, filePath) {
    return new Promise((resolve, reject) => {
        const child = spawn(editor, [filePath], {
            stdio: 'inherit'  // 親プロセスのstdio使用
        });
        
        child.on('exit', (code) => {
            if (code === 0) {
                resolve();
            } else {
                reject(new Error(`エディタが終了コード ${code} で終了しました`));
            }
        });
        
        child.on('error', reject);
    });
}

function getEditor() {
    // 環境変数から取得
    for (const env of ['VISUAL', 'EDITOR']) {
        const editor = process.env[env];
        if (editor) return editor;
    }
    
    // プラットフォーム別デフォルト
    const platform = process.platform;
    let candidates = [];
    
    switch (platform) {
        case 'win32':
            candidates = [
                path.join(process.env.USERPROFILE, 
                    'AppData/Local/Programs/Microsoft VS Code/Code.exe'),
                'code.cmd',
                'notepad.exe'
            ];
            break;
        case 'darwin':
            candidates = [
                '/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code',
                'code',
                '/usr/bin/vim',
                '/usr/bin/nano'
            ];
            break;
        default: // Linux
            candidates = ['code', 'vim', 'nano', 'gedit'];
    }
    
    // 利用可能なエディタを検索
    for (const editor of candidates) {
        if (fs.existsSync(editor) || isInPath(editor)) {
            return editor;
        }
    }
    
    throw new Error('利用可能なエディタが見つかりません');
}

function isInPath(command) {
    const { execSync } = require('child_process');
    try {
        execSync(`which ${command}`, { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

// Commander.jsでの使用例
program
    .command('create')
    .description('エディタで日報を作成')
    .option('-e, --editor <editor>', '使用するエディタを指定')
    .action(async (options) => {
        if (options.editor) {
            process.env.EDITOR = options.editor;
        }
        
        const template = `# 日報 - ${new Date().toISOString().split('T')[0]}

## プロジェクト
[プロジェクト名を入力]

## 本日の作業
- 

## 明日の予定
- 

## 所感・課題
`;
        
        try {
            const content = await openEditor(template, '.md');
            if (content) {
                await saveReport(content);
                console.log('日報を保存しました');
            } else {
                console.log('日報の作成をキャンセルしました');
            }
        } catch (error) {
            console.error('エラー:', error.message);
        }
    });
```

## 4. Rust

### 基本実装
```rust
use std::env;
use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;
use std::process::Command;
use tempfile::NamedTempFile;

pub fn open_editor(initial_content: &str, file_extension: &str) -> Result<String, Box<dyn std::error::Error>> {
    let editor = get_editor()?;
    
    // テンポラリファイル作成
    let mut tmp_file = NamedTempFile::new()?;
    let tmp_path = tmp_file.path().with_extension(file_extension);
    
    // 初期内容を書き込み
    if !initial_content.is_empty() {
        tmp_file.write_all(initial_content.as_bytes())?;
        tmp_file.flush()?;
    }
    
    // ファイルをリネーム（拡張子付きで）
    fs::copy(tmp_file.path(), &tmp_path)?;
    
    // エディタを起動
    let status = Command::new(&editor)
        .arg(&tmp_path)
        .status()?;
    
    if !status.success() {
        return Err(format!("エディタが正常に終了しませんでした: {}", status).into());
    }
    
    // ファイル内容を読み込み
    let content = fs::read_to_string(&tmp_path)?;
    
    // テンポラリファイルを削除
    let _ = fs::remove_file(&tmp_path);
    
    Ok(content.trim().to_string())
}

fn get_editor() -> Result<String, Box<dyn std::error::Error>> {
    // 環境変数から取得
    for env_var in &["VISUAL", "EDITOR"] {
        if let Ok(editor) = env::var(env_var) {
            return Ok(editor);
        }
    }
    
    // プラットフォーム別デフォルト
    let candidates = if cfg!(target_os = "windows") {
        vec![
            format!("{}\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", 
                   env::var("USERPROFILE").unwrap_or_default()),
            "code.cmd".to_string(),
            "notepad.exe".to_string(),
        ]
    } else if cfg!(target_os = "macos") {
        vec![
            "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code".to_string(),
            "code".to_string(),
            "/usr/bin/vim".to_string(),
            "/usr/bin/nano".to_string(),
        ]
    } else {
        vec![
            "code".to_string(),
            "vim".to_string(),
            "nano".to_string(),
            "gedit".to_string(),
        ]
    };
    
    // 利用可能なエディタを検索
    for editor in candidates {
        if PathBuf::from(&editor).exists() || which::which(&editor).is_ok() {
            return Ok(editor);
        }
    }
    
    Err("利用可能なエディタが見つかりません".into())
}

// Clapでの使用例
use clap::{Arg, Command};

fn main() {
    let app = Command::new("smart-nippo")
        .subcommand(
            Command::new("create")
                .about("エディタで日報を作成")
                .arg(
                    Arg::new("editor")
                        .short('e')
                        .long("editor")
                        .value_name("EDITOR")
                        .help("使用するエディタを指定")
                )
        );
    
    let matches = app.get_matches();
    
    if let Some(create_matches) = matches.subcommand_matches("create") {
        if let Some(editor) = create_matches.get_one::<String>("editor") {
            env::set_var("EDITOR", editor);
        }
        
        let template = format!(
            "# 日報 - {}\n\n## プロジェクト\n[プロジェクト名を入力]\n\n## 本日の作業\n- \n\n## 明日の予定\n- \n\n## 所感・課題\n",
            chrono::Local::now().format("%Y-%m-%d")
        );
        
        match open_editor(&template, "md") {
            Ok(content) if !content.is_empty() => {
                save_report(&content);
                println!("日報を保存しました");
            }
            Ok(_) => println!("日報の作成をキャンセルしました"),
            Err(e) => eprintln!("エラー: {}", e),
        }
    }
}
```

## 既存ライブラリの活用

### Python - Clickのエディタサポート
```python
import click

@click.command()
def create_report():
    # Clickの組み込みエディタ機能
    content = click.edit(
        '\n\n# 日報テンプレート\n# この行より下に入力してください',
        extension='.md'
    )
    
    if content:
        # コメント行を除去
        lines = [line for line in content.split('\n') 
                if not line.strip().startswith('#')]
        clean_content = '\n'.join(lines).strip()
        
        if clean_content:
            save_report(clean_content)
            click.echo("日報を保存しました")
```

### Go - Survey/Bubbletea のエディタ統合
```go
import "github.com/AlecAivazis/survey/v2"

func inputWithEditor() {
    content := ""
    prompt := &survey.Editor{
        Message:       "日報を入力してください",
        Default:       "# 日報テンプレート\n",
        FileName:      "*.md",
    }
    survey.AskOne(prompt, &content)
}
```

## 比較表

| 項目 | Python | Go | Node.js | Rust |
|------|--------|-----|---------|------|
| **実装の簡単さ** | ◎ | ○ | ○ | △ |
| **エディタ検出** | ◎ | ○ | ○ | ○ |
| **クロスプラットフォーム** | ◎ | ◎ | ◎ | ◎ |
| **既存ライブラリサポート** | ◎ | ○ | △ | △ |
| **エラーハンドリング** | ○ | ◎ | ○ | ◎ |
| **テンポラリファイル管理** | ◎ | ○ | ○ | ◎ |

## 高度な機能

### VSCode統合
```python
def open_vscode_with_snippets():
    """VSCodeでスニペットと拡張機能を活用"""
    # .vscode/settings.json で日報用設定
    # 日報専用のワークスペースを作成
    vscode_workspace = {
        "folders": [],
        "settings": {
            "editor.wordWrap": "on",
            "markdown.preview.breaks": True
        },
        "extensions": {
            "recommendations": [
                "yzhang.markdown-all-in-one"
            ]
        }
    }
```

### 自動保存・復元機能
```python
def open_editor_with_backup(content):
    """編集中の内容を自動保存"""
    backup_dir = Path.home() / '.smart-nippo' / 'drafts'
    backup_dir.mkdir(parents=True, exist_ok=True)
    
    backup_file = backup_dir / f"draft_{datetime.now().isoformat()}.md"
    
    try:
        # バックアップ作成
        backup_file.write_text(content)
        
        # エディタ起動
        result = open_editor(content)
        
        # 成功時はバックアップ削除
        backup_file.unlink()
        return result
        
    except KeyboardInterrupt:
        print(f"下書きを保存しました: {backup_file}")
        raise
```

## 結論

**エディタ連携の実装難易度:**
```
Python > Go = Node.js > Rust
```

**推奨実装:**
1. **Python + Click**: 最も簡単（`click.edit()`）
2. **Go**: 十分な機能と配布性のバランス
3. **Node.js**: Web開発者には馴染みやすい
4. **Rust**: 最も堅牢だが実装が複雑

**重要な考慮点:**
- エディタの自動検出（環境変数、PATH、デフォルト）
- クロスプラットフォーム対応
- テンポラリファイルの適切な管理
- VSCode等の特定エディタとの統合オプション
- 編集中断時の下書き保存機能

すべての言語でgitライクなエディタ連携は実装可能ですが、Pythonが最も簡単で、Goが配布を考慮した際の最適解となります。