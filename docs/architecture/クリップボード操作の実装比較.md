# クリップボード操作の実装比較

## 概要
日報出力をクリップボードにコピーする機能について、各言語でのマルチOS対応実装を検討します。

## 各言語での実装方法

### 1. Python

#### 方法1: pyperclip（推奠）
```python
import pyperclip
import platform
import subprocess

def copy_to_clipboard(text):
    """マルチプラットフォーム対応のクリップボードコピー"""
    try:
        pyperclip.copy(text)
        return True
    except Exception as e:
        # pyperclipが失敗した場合のフォールバック
        return copy_with_command(text)

def copy_with_command(text):
    """コマンドラインツールを使用したコピー"""
    system = platform.system()
    
    try:
        if system == "Darwin":  # macOS
            subprocess.run(["pbcopy"], input=text.encode("utf-8"), check=True)
        elif system == "Linux":
            # WSL検出
            if "microsoft" in platform.uname().release.lower():
                subprocess.run(["clip.exe"], input=text.encode("utf-8"), check=True)
            else:
                # 通常のLinux (xclipが必要)
                subprocess.run(["xclip", "-selection", "clipboard"], 
                             input=text.encode("utf-8"), check=True)
        elif system == "Windows":
            subprocess.run(["clip"], input=text.encode("utf-8"), check=True)
        return True
    except Exception:
        return False
```

**依存関係:**
- macOS: 追加不要（pbcopy標準搭載）
- Windows: 追加不要（clip標準搭載）
- Linux: xclipまたはxselのインストールが必要
- WSL: Windows側のclip.exeを利用

#### 方法2: tkinter（標準ライブラリ）
```python
import tkinter as tk

def copy_to_clipboard_tk(text):
    """tkinterを使用（GUIライブラリだが非表示で使用）"""
    root = tk.Tk()
    root.withdraw()  # ウィンドウを非表示
    root.clipboard_clear()
    root.clipboard_append(text)
    root.update()  # クリップボードを更新
    root.destroy()
```

**問題点:** 
- Linux環境でX11が必要
- SSHセッションでは動作しない

### 2. Go

#### 実装例
```go
package clipboard

import (
    "fmt"
    "os/exec"
    "runtime"
    "strings"
)

func Copy(text string) error {
    switch runtime.GOOS {
    case "darwin":
        return copyDarwin(text)
    case "linux":
        return copyLinux(text)
    case "windows":
        return copyWindows(text)
    default:
        return fmt.Errorf("unsupported platform: %s", runtime.GOOS)
    }
}

func copyDarwin(text string) error {
    cmd := exec.Command("pbcopy")
    cmd.Stdin = strings.NewReader(text)
    return cmd.Run()
}

func copyLinux(text string) error {
    // WSL検出
    if isWSL() {
        cmd := exec.Command("clip.exe")
        cmd.Stdin = strings.NewReader(text)
        return cmd.Run()
    }
    
    // 通常のLinux
    cmd := exec.Command("xclip", "-selection", "clipboard")
    cmd.Stdin = strings.NewReader(text)
    return cmd.Run()
}

func copyWindows(text string) error {
    cmd := exec.Command("cmd", "/c", "clip")
    cmd.Stdin = strings.NewReader(text)
    return cmd.Run()
}

func isWSL() bool {
    cmd := exec.Command("uname", "-r")
    output, err := cmd.Output()
    if err != nil {
        return false
    }
    return strings.Contains(strings.ToLower(string(output)), "microsoft")
}
```

#### 既存ライブラリ: golang-design/clipboard
```go
import "golang.design/x/clipboard"

func main() {
    // 初期化
    err := clipboard.Init()
    if err != nil {
        panic(err)
    }
    
    // テキストをコピー
    clipboard.Write(clipboard.FmtText, []byte("日報内容"))
}
```

**注意:** CGOを使用するため、静的バイナリにできない

### 3. Node.js

#### 実装例
```javascript
const { exec } = require('child_process');
const os = require('os');

function copyToClipboard(text) {
    return new Promise((resolve, reject) => {
        let command;
        
        switch (process.platform) {
            case 'darwin':
                command = 'pbcopy';
                break;
            case 'win32':
                command = 'clip';
                break;
            case 'linux':
                // WSL検出
                if (isWSL()) {
                    command = 'clip.exe';
                } else {
                    command = 'xclip -selection clipboard';
                }
                break;
            default:
                reject(new Error(`Unsupported platform: ${process.platform}`));
                return;
        }
        
        const proc = exec(command, (error) => {
            if (error) {
                reject(error);
            } else {
                resolve();
            }
        });
        
        proc.stdin.write(text);
        proc.stdin.end();
    });
}

function isWSL() {
    try {
        const release = require('fs').readFileSync('/proc/version', 'utf8');
        return release.toLowerCase().includes('microsoft');
    } catch {
        return false;
    }
}
```

#### 既存ライブラリ: clipboardy
```javascript
const clipboardy = require('clipboardy');

// 同期版
clipboardy.writeSync('日報内容');

// 非同期版
await clipboardy.write('日報内容');
```

### 4. Rust

#### 実装例
```rust
use std::process::{Command, Stdio};
use std::io::Write;

#[cfg(target_os = "macos")]
fn copy_to_clipboard(text: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("pbcopy")
        .stdin(Stdio::piped())
        .spawn()?;
    
    child.stdin.as_mut().unwrap().write_all(text.as_bytes())?;
    child.wait()?;
    Ok(())
}

#[cfg(target_os = "windows")]
fn copy_to_clipboard(text: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut child = Command::new("cmd")
        .args(&["/c", "clip"])
        .stdin(Stdio::piped())
        .spawn()?;
    
    child.stdin.as_mut().unwrap().write_all(text.as_bytes())?;
    child.wait()?;
    Ok(())
}

#[cfg(target_os = "linux")]
fn copy_to_clipboard(text: &str) -> Result<(), Box<dyn std::error::Error>> {
    // WSL検出
    let is_wsl = std::fs::read_to_string("/proc/version")
        .map(|s| s.to_lowercase().contains("microsoft"))
        .unwrap_or(false);
    
    let mut child = if is_wsl {
        Command::new("clip.exe")
            .stdin(Stdio::piped())
            .spawn()?
    } else {
        Command::new("xclip")
            .args(&["-selection", "clipboard"])
            .stdin(Stdio::piped())
            .spawn()?
    };
    
    child.stdin.as_mut().unwrap().write_all(text.as_bytes())?;
    child.wait()?;
    Ok(())
}
```

#### 既存ライブラリ: clipboard
```rust
use clipboard::{ClipboardContext, ClipboardProvider};

fn main() {
    let mut ctx: ClipboardContext = ClipboardProvider::new().unwrap();
    ctx.set_contents("日報内容".to_owned()).unwrap();
}
```

## 比較表

| 項目 | Python | Go | Node.js | Rust |
|------|--------|-----|---------|------|
| **実装の容易さ** | ◎ | ○ | ○ | △ |
| **外部依存** | pyperclip | なし/clipboard | clipboardy | clipboard-rs |
| **Linux追加要件** | xclip | xclip | xclip | xclip |
| **WSL対応** | ○ | ○ | ○ | ○ |
| **エラーハンドリング** | ○ | ◎ | ○ | ◎ |
| **バイナリサイズへの影響** | 小 | 小 | 小 | 小 |

## OS別の注意点

### macOS
- 全言語で`pbcopy`コマンドが利用可能
- 追加インストール不要

### Windows
- 全言語で`clip`コマンドが利用可能
- PowerShellの`Set-Clipboard`も使用可能

### Linux
- **要インストール**: `xclip`または`xsel`
  ```bash
  # Ubuntu/Debian
  sudo apt-get install xclip
  
  # Fedora
  sudo dnf install xclip
  ```
- SSH接続時はX11フォワーディングが必要

### WSL
- Windows側の`clip.exe`を呼び出すのが最も確実
- `/proc/version`でWSL環境を検出

## 推奨実装

### 共通のエラーハンドリング戦略
```python
def copy_to_clipboard(text, fallback=True):
    """
    クリップボードへのコピーを試みる
    失敗時はユーザーに手動コピーを促す
    """
    methods = [
        ("ライブラリ", copy_with_library),
        ("システムコマンド", copy_with_command),
    ]
    
    for method_name, method in methods:
        try:
            if method(text):
                return True
        except Exception as e:
            logger.debug(f"{method_name}でのコピー失敗: {e}")
    
    if fallback:
        print("\n[クリップボードへのコピーに失敗しました]")
        print("以下の内容を手動でコピーしてください:")
        print("-" * 40)
        print(text)
        print("-" * 40)
    
    return False
```

### インストール時の説明
```markdown
## Linux環境での追加設定

クリップボード機能を使用するには、以下のインストールが必要です：

```bash
# Ubuntu/Debian
sudo apt-get install xclip

# GUI環境がない場合（サーバー等）
# クリップボード機能は利用できませんが、
# テキスト出力は正常に動作します
```
```

## 結論

**実装の推奨順位:**

1. **Python + pyperclip**: 最も簡単で信頼性が高い
2. **Go/Node.js/Rust + システムコマンド**: 外部ライブラリ不要で軽量
3. **各言語の専用ライブラリ**: より高機能だが依存関係が増える

**重要な設計方針:**
- クリップボード操作の失敗を想定し、フォールバック機能を実装
- Linux環境では追加パッケージが必要なことを明記
- WSL環境を自動検出して適切なコマンドを使用